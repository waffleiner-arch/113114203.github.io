// engine.js (core, importable)
import BAL from './balance.js';
import Combat from './combat.js';
import Crafting from './crafting.js';
import Quests from './quests.js';
import Maps from './maps.js';

const Engine = (function(){
  const STATE = { rp:60,rpMax:60,nb:0,nr:1,time:0, world:{ threatTier:1, morale:100, resources:120, publicKnowledge:0, artifacts:0, evacuated:0 }, roster:[{id:'kim',name:'Kim Dokja',role:'reader',stats:{attack:5,defense:3,speed:5},hp:100,maxHp:100,bond:60},{id:'mira',name:'Captain Mira',role:'tank',stats:{attack:7,defense:5,speed:4},hp:110,maxHp:110,bond:50},{id:'haejin',name:'Haejin',role:'engineer',stats:{attack:4,defense:3,speed:5},hp:90,maxHp:90,bond:55}], inventory:{}, graph:{scenarios:{},nodes:{}}, eventQueue:[], flags:{}, questsMeta:{} };
  const CFG = Object.assign({}, BAL, { SAVE_KEY:'omnigame_v2' });
  const HOOKS = { onUpdate:null, onLog:null, onContract:null };
  function log(m){ if(typeof HOOKS.onLog==='function') HOOKS.onLog(m); else console.log('[Engine] '+m); }
  function save(){ try{ localStorage.setItem(CFG.SAVE_KEY, JSON.stringify({state:STATE,savedAt:Date.now()})); log('Saved game'); return true;}catch(e){log('Save failed:'+e.message);return false;} }
  function load(){ try{ const raw = localStorage.getItem(CFG.SAVE_KEY); if(!raw) return false; const p=JSON.parse(raw); Object.assign(STATE,p.state||{}); log('Loaded game'); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return true;}catch(e){log('Load failed:'+e.message);return false;} }
  async function loadGraph(url){ const r=await fetch(url); if(!r.ok) throw new Error('Graph fail'); const j=await r.json(); STATE.graph=j; log('Graph loaded'); if(j.maps) j.maps.forEach(m=>Maps.register(m)); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return j; }
  function snapshot(){ return { rp:Math.round(STATE.rp), rpMax:STATE.rpMax, nb:Math.round(STATE.nb), time:STATE.time, world:Object.assign({},STATE.world), roster:STATE.roster.map(r=>({id:r.id,name:r.name,hp:r.hp,maxHp:r.maxHp,bond:r.bond})), inventory:Crafting.dump(), quests:Quests.getActive() }; }
  function scaledCost(base){ return Math.ceil(base * CFG.THREAT_SCALE(STATE.world.threatTier)); }
  function spendRP(amount, reason='generic'){ const cost = scaledCost(amount); if(cost>STATE.rp){ log('Insufficient RP'); return {ok:false}; } STATE.rp -= cost; const c = cost * CFG.ALPHA; const nbGain = Math.floor(c * (1 + STATE.nb/100)); STATE.nb += nbGain; log(`${reason}: RP-${cost} NB+${nbGain}`); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); applyNBEffects(); return {ok:true,cost,nbGain}; }
  function applyNBEffects(){ const nb=STATE.nb; if(nb>=CFG.NB_THRESH[2]) enqueueEvent({type:'CONSTELLATION_INTEREST',severity:3,when:STATE.time+1}); else if(nb>=CFG.NB_THRESH[1]){ STATE.rp=Math.max(0,STATE.rp-6); enqueueEvent({type:'NARRATIVE_CORRUPTION',severity:2,when:STATE.time+0.5}); } else if(nb>=CFG.NB_THRESH[0]) enqueueEvent({type:'NPC_SUSPICION',severity:1,when:STATE.time+0.2}); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); }
  function enqueueEvent(ev){ if(!ev.when) ev.when = STATE.time; STATE.eventQueue.push(ev); STATE.eventQueue.sort((a,b)=>a.when-b.when); }
  function processEvents(){ const now=STATE.time; const due=STATE.eventQueue.filter(e=>e.when<=now); STATE.eventQueue=STATE.eventQueue.filter(e=>e.when>now); due.forEach(handleEvent); }
  function handleEvent(ev){ switch(ev.type){ case 'NPC_SUSPICION': if(STATE.roster.length){ const idx=Math.floor(Math.random()*STATE.roster.length); const npc=STATE.roster[idx]; npc.bond=Math.max(0,npc.bond-5*ev.severity); log(`${npc.name} suspicion -${5*ev.severity}`); } break; case 'NARRATIVE_CORRUPTION': STATE.world.morale=Math.max(0,STATE.world.morale-6*ev.severity); log('Narrative corruption'); break; case 'CONSTELLATION_INTEREST': enqueueEvent({type:'CONSTELLATION_CONTRACT',severity:ev.severity,when:STATE.time+4}); break; case 'CONSTELLATION_CONTRACT': if(typeof HOOKS.onContract==='function') HOOKS.onContract({text:'Constellation offers favor',favor:30*ev.severity,costArtifacts:3*ev.severity}); break; default: log('Unhandled event: '+ev.type);} if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); }
  function tick(hours=1){ for(let i=0;i<hours;i++){ STATE.time+=1; const regen=CFG.RP_REGEN_BASE+0.05*STATE.nr; STATE.rp=Math.min(STATE.rpMax,STATE.rp+regen); const decay=CFG.NB_DECAY_BASE+0.02*STATE.nr; STATE.nb=Math.max(0,STATE.nb-decay); processEvents(); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return snapshot(); }
  function getNode(id){ return STATE.graph.nodes && STATE.graph.nodes[id] ? STATE.graph.nodes[id] : null; }
  function previewNode(nodeId){ const node = getNode(nodeId); if(!node) return {ok:false}; let chance = 0.8; if(node.checks && node.checks.length){ const avg = node.checks.reduce((s,ch)=>s+ch.difficulty,0)/node.checks.length; chance = Math.max(0.05, 0.95 - (avg/200)); } chance -= Math.min(0.35, STATE.nb/600); return { ok:true, chance: Math.round(chance*100) }; }
  function resolveNode(nodeId, opts={}){ const node = getNode(nodeId); if(!node){ log('Node not found: '+nodeId); return {ok:false}; } if(node.timeCost) tick(node.timeCost); if(node.suppliesCost) STATE.world.resources = Math.max(0, STATE.world.resources - node.suppliesCost); if(node.type==='combat'){ const enemies = (node.enemies||[]).map(t=>Combat.spawnEnemy(t)); const party = STATE.roster.filter(r=>r.alive).map(r=>({id:r.id,name:r.name,stats:r.stats,hp:r.hp,maxHp:r.maxHp})); Combat.runEncounter(party,enemies,{ onEnd:(result)=>{ if(result.victory){ if(node.rewards){ if(node.rewards.evacuated) STATE.world.evacuated += node.rewards.evacuated; if(node.rewards.supplies) STATE.world.resources += node.rewards.supplies; if(node.rewards.rp) STATE.rp = Math.min(STATE.rpMax, STATE.rp + node.rewards.rp); } log(`Combat ${nodeId} victory`); } else { STATE.world.morale = Math.max(0, STATE.world.morale - (node.failure?.moraleLoss||10)); log(`Combat ${nodeId} lost`); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); } }); return {ok:true,type:'combat'}; } if(node.type==='craft'){ const craftRes = Crafting.craft(node.recipe); if(craftRes.ok){ if(craftRes.result.supplies) STATE.world.resources += craftRes.result.supplies; Object.keys(craftRes.result).forEach(k=>{ if(k!=='supplies' && k!=='hpRestore'){ STATE.inventory[k] = (STATE.inventory[k]||0) + (craftRes.result[k]||1); } }); log(`Crafted ${node.recipe}`); } else { log('Craft failed'); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return {ok:craftRes.ok}; } if(node.type==='quest'){ if(node.questTrigger){ Quests.progress(node.questTrigger.questId,node.questTrigger.objId,node.questTrigger.amount||1); log(`Quest progress ${node.questTrigger.questId}`); } if(node.rewards){ if(node.rewards.evacuated) STATE.world.evacuated += node.rewards.evacuated; if(node.rewards.rp) STATE.rp = Math.min(STATE.rpMax, STATE.rp + node.rewards.rp); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return {ok:true}; } if(node.type==='travel'){ if(node.targetMap) { Maps.enter(node.targetMap); log(`Travelled to ${node.targetMap}`); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return {ok:true}; } const pre = previewNode(nodeId); const succeeded = Math.random() < (pre.chance/100); if(succeeded){ if(node.rewards){ if(node.rewards.evacuated) STATE.world.evacuated += node.rewards.evacuated; if(node.rewards.rp) STATE.rp = Math.min(STATE.rpMax, STATE.rp + node.rewards.rp); } log(`${node.title} succeeded`); } else { if(node.failure){ STATE.world.morale = Math.max(0, STATE.world.morale - (node.failure.civiliansLoss||5)); } log(`${node.title} failed`); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return {ok:true,success:succeeded}; }
  function actionRewrite(nodeId,rewriteSpec){ const base = (rewriteSpec && rewriteSpec.severity==='major') ? CFG.COSTS.REWRITE_MAJOR : CFG.COSTS.REWRITE_MINOR; const r = spendRP(base,'Rewrite'); if(!r.ok) return r; const node = getNode(nodeId); if(!node) return {ok:false}; if(rewriteSpec.timeDelta) node.timeCost = Math.max(0,(node.timeCost||0)+rewriteSpec.timeDelta); if(rewriteSpec.diffDelta && Array.isArray(node.checks)) node.checks.forEach(ch=> ch.difficulty = Math.max(1,ch.difficulty + rewriteSpec.diffDelta)); log(`Rewrite applied to ${nodeId}`); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return {ok:true}; }
  function createQuest(q){ Quests.createQuest(q); STATE.questsMeta[q.id]=q; if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); }
  function craftingAdd(item,qty=1){ Crafting.add(item,qty); STATE.inventory = Crafting.dump(); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); }
  function craftingCan(recipe){ return Crafting.canCraft(recipe); }
  function craftingCraft(recipe){ const r=Crafting.craft(recipe); STATE.inventory = Crafting.dump(); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return r; }
  function recruit(t){ const npc = { id:'npc_'+Math.random().toString(36).slice(2,9), name:t.name, role:t.role, stats:t.stats||{}, hp:t.hp||80, maxHp:t.hp||80, bond:t.bond||40, alive:true }; STATE.roster.push(npc); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return npc; }
  return { init:function(opts){ if(opts && opts.hooks) Object.assign(HOOKS,opts.hooks); if(opts && opts.loadFrom) loadGraph(opts.loadFrom).catch(e=>log('Graph load fail: '+e.message)); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return this; }, save, load, tick, snapshot, spendRP, resolveNode, previewNode, createQuest, craftingAdd, craftingCan, craftingCraft, recruit, getGraph:()=>STATE.graph, getState:()=>STATE };
})();
export default Engine;
