// src/engine.js
const Engine = (function(){
  const STATE = {
    rp: 60, rpMax: 60, nb: 0, nr: 1,
    time: 0,
    world: { threatTier: 1, morale: 100, resources: 300, publicKnowledge: 0, artifacts: 0 },
    roster: [],
    currentScenario: null,
    queuedScenarios: [],
    eventQueue: [],
    flags: {}
  };
  const CFG = {
    ALPHA: 0.6,
    RP_REGEN_BASE: 1,
    NB_DECAY_BASE: 0.5,
    COSTS: { HINT:5, PREVIEW:12, DELAY:20, REWRITE_MINOR:40, REWRITE_MAJOR:90, BURY_TRUTH:30, STORY_SAVE_BASE:80 },
    NB_THRESH: [50,120,240],
    THREAT_SCALE: (t)=> 1 + 0.15*(t-1),
    SAVE_KEY: "omnigame_v1"
  };
  let GRAPH = { scenarios:{}, nodes:{} };
  const HOOKS = { onUpdate:null, onLog:null, onContract:null, onScenarioStart:null };
  function log(msg){ if(typeof HOOKS.onLog === 'function') HOOKS.onLog(msg); else console.log("[Engine] "+msg); }
  function save(){ try{ const payload={state:STATE,savedAt:Date.now()}; localStorage.setItem(CFG.SAVE_KEY, JSON.stringify(payload)); log("Game saved"); return true;}catch(e){log("Save failed: "+e.message);return false;} }
  function load(){ try{ const raw=localStorage.getItem(CFG.SAVE_KEY); if(!raw) return false; const payload=JSON.parse(raw); Object.assign(STATE, payload.state||{}); log("Game loaded"); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return true;}catch(e){log("Load failed: "+e.message);return false;} }
  async function loadScenarios(url){ const res = await fetch(url); if(!res.ok) throw new Error("Failed to load scenarios"); GRAPH = await res.json(); log("Scenarios loaded"); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return GRAPH; }
  function snapshot(){ return { rp: Math.round(STATE.rp), rpMax: STATE.rpMax, nb: Math.round(STATE.nb), nr: STATE.nr, time: STATE.time, world: Object.assign({}, STATE.world), roster: STATE.roster.map(r => ({ id:r.id, name:r.name, bond:r.bond, alive:r.alive })), currentScenario: STATE.currentScenario, queuedScenarios: STATE.queuedScenarios.slice() }; }
  function scaledCost(base){ return Math.ceil(base * CFG.THREAT_SCALE(STATE.world.threatTier)); }
  function spendRP(amount, reason="generic"){ const cost = scaledCost(amount); if(cost > STATE.rp){ log(`Not enough RP for ${reason}`); return { ok:false, reason:"insufficient" }; } STATE.rp -= cost; const c = cost * CFG.ALPHA; const nbGain = Math.floor(c * (1 + STATE.nb/100)); STATE.nb += nbGain; log(`Spent ${cost} RP (${reason}) -> NB +${nbGain}`); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); applyNBEffects(); return { ok:true, spent:cost, nbGain }; }
  function applyNBEffects(){ const nb = STATE.nb; if(nb >= CFG.NB_THRESH[2]){ enqueueEvent({ type:"CONSTELLATION_INTEREST", severity:3, when: STATE.time + 1 }); log("NB critical -> constellation interest queued"); } else if(nb >= CFG.NB_THRESH[1]){ STATE.rp = Math.max(0, STATE.rp - 6); enqueueEvent({ type:"NARRATIVE_CORRUPTION", severity:2, when: STATE.time + 0.5 }); log("NB high -> corruption queued"); } else if(nb >= CFG.NB_THRESH[0]){ enqueueEvent({ type:"NPC_SUSPICION", severity:1, when: STATE.time + 0.2 }); log("NB moderate -> NPC suspicion queued"); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); }
  function enqueueEvent(ev){ if(typeof ev.when === 'undefined') ev.when = STATE.time; STATE.eventQueue.push(ev); STATE.eventQueue.sort((a,b)=> a.when - b.when); }
  function processEvents(){ const now = STATE.time; const due = STATE.eventQueue.filter(e => e.when <= now); STATE.eventQueue = STATE.eventQueue.filter(e => e.when > now); due.forEach(handleEvent); }
  function handleEvent(ev){ switch(ev.type){ case "NPC_SUSPICION": { if(STATE.roster.length){ const idx=Math.floor(Math.random()*STATE.roster.length); const npc=STATE.roster[idx]; npc.bond = Math.max(0, (npc.bond||50) - 5*ev.severity); log(`NPC suspicion: ${npc.name} bond -${5*ev.severity}`); } break; } case "NARRATIVE_CORRUPTION": { STATE.world.morale = Math.max(0, STATE.world.morale - 6*ev.severity); log("Narrative corruption applied"); break; } case "CONSTELLATION_INTEREST": { enqueueEvent({ type:"CONSTELLATION_CONTRACT", severity: ev.severity, when: STATE.time + 4 }); log("Constellation interest matured"); break; } case "CONSTELLATION_CONTRACT": { if(typeof HOOKS.onContract === 'function') HOOKS.onContract({ text: "A constellation offers favor for a cost. Accept?", favor: 30 * ev.severity, costArtifacts: 3 * ev.severity }); log("Constellation contract offered"); break; } default: log("Unhandled event: "+ev.type); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); }
  function tick(hours = 1){ for(let i=0;i<hours;i++){ STATE.time += 1; const regen = CFG.RP_REGEN_BASE + 0.05 * STATE.nr; STATE.rp = Math.min(STATE.rpMax, STATE.rp + regen); const decay = CFG.NB_DECAY_BASE + 0.02 * STATE.nr; STATE.nb = Math.max(0, STATE.nb - decay); processEvents(); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return snapshot(); }
  function getScenario(id){ return (GRAPH.scenarios && GRAPH.scenarios[id]) ? GRAPH.scenarios[id] : null; }
  function getNode(id){ return (GRAPH.nodes && GRAPH.nodes[id]) ? GRAPH.nodes[id] : null; }
  function startScenario(id){ const s = getScenario(id); if(!s){ log("Scenario not found: "+id); return {ok:false}; } STATE.currentScenario = { id: s.id, startedAt: STATE.time, state: "active", nodesVisited: [] }; log(`Scenario started: ${s.id}`); if(typeof HOOKS.onScenarioStart === 'function') HOOKS.onScenarioStart(s); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return { ok:true, scenario:s }; }
  function resolveNode(nodeId, opts = {}){ const node = getNode(nodeId); if(!node){ log("Node not found: "+nodeId); return {ok:false}; } if(node.timeCost) tick(node.timeCost); if(node.suppliesCost) STATE.world.resources = Math.max(0, STATE.world.resources - node.suppliesCost); let success = true; if(Array.isArray(node.checks) && node.checks.length){ node.checks.forEach(ch => { const assigned = Array.isArray(opts.assignedNPCs) ? opts.assignedNPCs.map(id => STATE.roster.find(r=>r.id===id)).filter(Boolean) : []; const statBonus = assigned.reduce((acc,n)=> acc + (n.stats?.[ch.stat]||0), 0); const roll = Math.random()*100 + (opts.bonus||0) + statBonus; if(roll < ch.difficulty) success = false; }); } if(success){ if(node.rewards){ if(node.rewards.rp) STATE.rp = Math.min(STATE.rpMax, STATE.rp + node.rewards.rp); if(node.rewards.artifacts) STATE.world.artifacts = (STATE.world.artifacts||0) + node.rewards.artifacts; if(node.rewards.supplies) STATE.world.resources += node.rewards.supplies; } log(`Node ${nodeId} succeeded`); } else { if(node.failure){ if(node.failure.civiliansLoss){ STATE.world.morale = Math.max(0, STATE.world.morale - node.failure.civiliansLoss); if(node.failure.killChance) { STATE.roster.forEach(r=>{ if(Math.random() < node.failure.killChance) { r.alive = false; log(`${r.name} was lost`); } }); } } } log(`Node ${nodeId} failed`); } if(STATE.currentScenario) STATE.currentScenario.nodesVisited.push({ nodeId, t: STATE.time, success }); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return { ok:true, success }; }
  function actionRewrite(nodeId, rewriteSpec){ const baseCost = (rewriteSpec && rewriteSpec.severity === 'major') ? CFG.COSTS.REWRITE_MAJOR : CFG.COSTS.REWRITE_MINOR; const result = spendRP(baseCost, "Rewrite"); if(!result.ok) return result; const node = getNode(nodeId); if(!node) return { ok:false, reason:"node_missing" }; if(rewriteSpec.timeDelta) node.timeCost = Math.max(0, (node.timeCost||0) + rewriteSpec.timeDelta); if(rewriteSpec.suppliesDelta) node.suppliesCost = Math.max(0, (node.suppliesCost||0) + rewriteSpec.suppliesDelta); if(rewriteSpec.diffDelta && Array.isArray(node.checks)) { node.checks.forEach(ch => { ch.difficulty = Math.max(1, ch.difficulty + (rewriteSpec.diffDelta||0)); }); } log(`Rewrite applied to ${nodeId}`); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return { ok:true, nodeId }; }
  function actionBuryTruth(targetFlag){ const cost = CFG.COSTS.BURY_TRUTH; const r = spendRP(cost, "BuryTruth"); if(!r.ok) return r; if(targetFlag && STATE.flags[targetFlag]) { delete STATE.flags[targetFlag]; STATE.world.publicKnowledge = Math.max(0, STATE.world.publicKnowledge - 20); log(`BuryTruth removed flag ${targetFlag}`); } else { STATE.world.publicKnowledge = Math.max(0, STATE.world.publicKnowledge - 8); log("BuryTruth used"); } if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return { ok:true }; }
  function actionStorySave(npcId){ const npc = STATE.roster.find(r=>r.id===npcId); if(!npc) return { ok:false, reason:"npc_missing" }; const base = CFG.COSTS.STORY_SAVE_BASE; const cost = Math.ceil(base * (1 + ((npc.role === 'canonical')?0.6:0))); if(cost > STATE.rp) return { ok:false, reason:"insufficient" }; STATE.rp -= cost; npc.storySaved = true; const c = cost * CFG.ALPHA; const nbGain = Math.floor(c * (1 + STATE.nb/100)); STATE.nb += nbGain; log(`StorySave: ${npc.name} locked. RP-${cost}, NB+${nbGain}`); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); applyNBEffects(); return { ok:true, cost, nbGain }; }
  function recruit(template){ const npc = { id: "npc_"+Math.random().toString(36).slice(2,9), name: template.name || "Survivor", role: template.role || "survivor", stats: Object.assign({}, template.stats || {}), bond: template.bond || 50, alive: true, storySaved: false }; STATE.roster.push(npc); log("Recruited: "+npc.name); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return npc; }
  function changeBond(npcId, delta){ const npc = STATE.roster.find(r=>r.id===npcId); if(!npc) return false; npc.bond = Math.max(0, Math.min(100, npc.bond + delta)); log(`${npc.name} bond ${delta>0?'+':''}${delta}`); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return true; }
  function previewNode(nodeId){ const node = getNode(nodeId); if(!node) return { ok:false }; let chance = 0.8; if(node.checks && node.checks.length){ const avg = node.checks.reduce((s,ch)=>s+ch.difficulty,0) / node.checks.length; chance = Math.max(0.05, 0.95 - (avg/200)); } chance -= Math.min(0.35, STATE.nb/600); chance = Math.max(0.02, Math.min(0.98, chance)); return { ok:true, chance: Math.round(chance*100) }; }
  return { init: function(opts){ if(opts && opts.hooks) Object.assign(HOOKS, opts.hooks); if(opts && opts.balance) Object.assign(CFG, opts.balance); if(opts && opts.loadFrom) loadScenarios(opts.loadFrom).catch(e=>log("LoadScenarios error: "+e.message)); if(opts && opts.autoload) load(); if(HOOKS.onUpdate) HOOKS.onUpdate(snapshot()); return this; }, loadScenarios, getScenario: getScenario, startScenario, resolveNode, spendRP, actionRewrite, actionBuryTruth, actionStorySave, recruit, changeBond, previewNode, tick, save, load, snapshot, getGraph: ()=> GRAPH };
})();
export default Engine;
